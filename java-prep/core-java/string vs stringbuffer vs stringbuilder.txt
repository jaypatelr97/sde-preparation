Difference between String and StringBuffer ?
- String object are immutable 
- StringBuffer are mutable 

What is immutability and mutability ?
- immutable means non-changable
- mutable means changable


Once we create string object we cant change its content. thus String object is immutable 
Once we create StringBuffer object we can change its content. thus StringBuffer is mutable

case 1-
String s = new String("durga");
s.concat("software");        (note here the method is concat)
SOP(s);
// output ==> durga

(output is durga and not durgasooftware bcoz s.concat() is not assigned top a new variable and printed.
how it will look in the memory 
_____________
|            |
|   durga    | <----- s (s poiting to durga object in the memory)
|_____________
________________
| durgasoftware |  <---------- (there is no variable that is pointing to the memory object)
|               |               (of durgasoftware. so it is available for garbage coll )
______________                  (and the op of the SOP statement will be durga)


)

case 2 - 
StringBuffer sb = new StringBuffer("durga");
sb.append("software");     (note that here the method is append)
SOP(sb);
// output --> durgasoftware

how it will look in the memory 
_____________
|            |
|   durga    | <----- sb (sb pointing to durga object in the memory)
|_____________

_____________
|                   |
|   durgasoftware   | <----- sb (sb pointing to durga object in the memory)
|_____________

sb is first pointing to the memory having value durga and then it will append the value in the same memory and update the value to durgasoftware

------------------------------------------------------------------------------------------

== vs equals()

case 1:
String s1 = new String("durga");
String s2 = new String("durga");
// here both the string objects are created with new keyword. so both will have new / different memory in the object.
SOP(s1==s2);  // == operator checks reference so both the objects are at different memoery location hence output is false
SOP(s1.equals(s2)); // String class overrides the equals method to compare the content. so here the output will be true.


case 2:
StringBuffer sb1 = new StringBuffer("durga");
StringBuffer sb2 = new StringBuffer("durga");

SOP(sb1 == sb2); // false (2 different StringBuffer objects created)
SOP(sb1.equals(sb2)); // false (StringBuffer does not override the Object class equals methods so it does reference/address comparison)

--------------------------------------------------------

Heap and String Pools concept -

String s = new String("durga");
-->
the object for the above statement is created in 2 areas - Heap area and String constant Pool area.

the object that is created in the SCP is not pointing to any reference. but it is not available for garbage collection also bcoz it is managed by JVM. More expalantion below -

(till 1.6 version SCP was saved in Method Area/ Permgen)
after 1.7 version SCP is moved to heap area only. i.e a small space is given in heap area for SCP.

String s = "durga";
in this the object will be created in the SCP area only.
it will first check if the object with the same content is already present. if yes then it will point to the same object or else it will create a new object.

Example - 
String s1 = new String("durga");
String s2 = new String("durga");
String s3 = "durga";
String s4 = "durga";

Heap                                          
___________
|          |
|          | <---- s1
| durga    |
| _______  |
___________
|          |
| durga    | <----- s2
|          |
------------

SCP 
__________
|         |
|durga    | <------- s3
|         | <------- s4
__________

Note - if any string object created at the runtime. it will be created in the heap area.
for every literal one object will be created in the string constant pool

Ex -
String s = new String("durga");
s.concat("software");
s = s.concat("solutions");

for every literal a new object will be created in the SCP area.

Heap                                                                  SCP

[durga] <-- X-- s                                                    [durga] 
[durgasoftware] <-- (no reference)                                  [software]
[durgasolutions] <-- s (s will start pointing to this object)       [solutions]    

EX -
String s1 = new String("spring");
s1.concat("fall");
String s2 = s1.concat("winter");
s2.concat("summer");
SOP(s1); // spring
SOP(S2); // springwinter

Heap                                                                          SCP
[spring] <---- s1                                                          [spring]
[springfall] <---- (no reference varaible)                                 [fall]
[springwinter] <---- s2                                                    [winter]
[springwintersummer] <----- no reference variable                          [summer]


EX:
main(){
String s1 = new String("You cannot change me");
String s2 = new String("You cannot change me");
SOP(s1==s2);  // false (bothe the objects are in different memory area so false)

String s3 = "You cannot change me";
SOP(s2==s3);  // false (one is in heap area and the other in SCP)

String s4 = "You cannot change me";
SOP(s3==s4); // true 

String s5 = "You cannot " + "change me";   
SOP(s4==s5); // true (at compile time only both the literals are cancatinated and formed to one literal. so t runtime it is one string literal only )

String s6 = "You cannot ";
String s7 = s6 + "change me"; // here + is done on varaible and literal so it will be performed at runtime and not compile time. when executed at runtime it will be created in heap memory
SOP(s4==s7); // false

final String s8 = "You cannot ";
String s9 = s8 + "change me"; // every final variable will be replaced by value at the compile time only. so constant + constant will be performed at compile time only
SOP(s4==s9); // true
}

heap                                                                            SCP
[You cannot change me] <--- s1              [You cannot change me] <--- s3, s4, s5, s7, s9
[You cannot change me] <--- s2                                     
                                               [you cannot]  <-- s6, s8
                                               [change me]
                         
                 [1:19:35]                      
-------------------------
advantage with SCP - 
In SCP same object area can be reused for multiple references. so no need to create new objects multiple times. example - Voter registration form (most of the parametesrs are string) so Hyderabad as state no need to save multiple times it will be saved only once in the SCP area. 

Disadvantages of SCP -
see if immutablity concept was not provided by java, then 1 crore refer variable are pointing to Hyderabad object. so if you change any one object value then all the reference value will get updated. so java people came up with concept of immutability. with immutable objects the objects cannot be modified. a new object will be created and poited to taht.

-------------------------------------
FAQ's 
1. why SCP is avaibale only for String object but not for StringBuffer ?
--> String is most commonly used data type in java. so java people provided special feture to string object only. StringBuffer is not very much used so no special behaviour
2. Why String objects are immutable whereas StringBuffer objects are mutable?
reusing the same object with the help of SCP so String object is immutable
3. Addition to String objects any other objects are immutable in java ?
yes, all wrapper class objects

-----------------------------------------
important constructors of string class 


important method of string class 
1. public char charAt(int index)
2. equals
3. replace
4. substring(int idx)
5. substring(int start, int end)
6. indexOf()
7. lastIndexOf()
8. toLowerCase()
9. toUpperCase()
10. trim()

note - 
 if because of our operation there is change in our content then only a new object will be created. if there is no change in the content then it will not create a new object


main(){
String s1 = new String("durga");
String s2 = s1.toUpperCase();
String s3 = s1.toLowerCase();
SOP(s1==s2); // false
SOP(s1==s3); // true

}


-------------------------------------------------
creation of our own immutable class

immutable means that the object should not be modified after its creations.

if the content is same use same object
if content modified create different object
make class as final so the method cannot be overriddedn

code 
public final class Test{
private int i;

public Test(){
this.i = i;
}

public void modify(int i){
if(this.i==i){
return this;
} else {
return new Test(i);
}

}

--------------------------------------------------------------

final vs immutable 
Scanaerio - If i mark StringBuffer object as final will it becoming immutable? ans is NO.
Explanation - 
if a reference variable is marked as final, then we cannot reassign the variable with new value but it does not garuntee that the content of the same object will not get modified.

Code Proof :
public class Test{
main(){
final StringBuffer sb = new StringBuffer("durga");
sb.append("software");

SOP(sb); // here ans will be durgasoftware

sb = new StringBuffer("durgasoft") // compile time error because reassigning to final variable not allowed
}

}

conclusion = by making reference vaiable as final we cannot achieve immutability

we cannot make StringBuffer immutable

------------------------------------------
need of StringBuffer

If content keep on changing then dont use String because String is immutable and it will create new object everytime.
you StringBuffer in such places were content keep on changing

String does not have capacity 
StringBuffer has capacity concept

default capacity of the StringBuffer is 16. once it is full it will create new StringBuffer object with bigger capacity (current capacity + 1) * 2

------------------------------------------------
need of StringBuilder and differences with StringBuffer? 

every method in StringBuffer is synchronized





